#include"STC15F2K60S2.H"
#include"intrins.h"

volatile unsigned long currenttim=0;
unsigned long now=0;
const unsigned char code Display[128]={0x00,0x5C,0x54,0x74,0x00,0x7C,0x44,0x7C,0x00,0x7C,0x44,0x7C,0x00,0x7C,0x54,0x5C,
0x00,0x04,0x00,0x7C,0x00,0x04,0x00,0x5C,0x54,0x74,0x00,0x40,0x40,0x7C,0x00,0x10,
0x10,0x10,0x10,0x10,0x10,0x00,0x5C,0x54,0x74,0x00,0x7C,0x44,0x7C,0x00,0x5C,0x54,
0x74,0x00,0x7C,0x54,0x5C,0x00,0x04,0x00,0x7C,0x00,0x04,0x00,0x5C,0x54,0x74,0x00,
0x40,0x40,0x7C,0x00,0x00,0x38,0x04,0x38,0x04,0x38,0x00,0x5C,0x00,0x3A,0x2A,0x2E,
0x00,0x7C,0x10,0x1C,0x00,0x00,0x38,0x20,0x38,0x20,0x38,0x00,0x38,0x0A,0x3E,0x00,
0x00,0x5C,0x54,0x74,0x00,0x7C,0x44,0x7C,0x00,0x3A,0x2A,0x2E,0x00,0x3A,0x00,0x3A,
0x00,0x3A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

const unsigned char code picture[8]={0x20,0x70,0x7C,0x3E,0x3E,0x7C,0x70,0x20};

void Timer0Init(void);
void MS_delay(unsigned int ms);
void US_delay(unsigned char us);
void Display_line(unsigned char row,unsigned char Byte);
void display_picture(len);
void static_display(void);
void LED_Display(unsigned char Byte);

void main(void)
{
	Timer0Init();
	EA=1;
	now=currenttim;
	while(1)
	{
		static_display();
		if(currenttim-now>500)
		{
			break;
		}
	}
	display_picture(128);
}

void Timer0Init(void)		//1毫秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xCD;		//设置定时初值
	TH0 = 0xD4;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0=1;
}

void Timer0(void) interrupt 1
{
	currenttim++;
}

void MS_delay(unsigned int ms)
{
	unsigned long prev=currenttim+ms;
	while(prev>currenttim);
}

void US_delay(unsigned char us)
{
	unsigned char i=0;
	for(i=0;i<us;i++)
	{
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
		_nop_();
	}
}

void Display_line(unsigned char row,unsigned char Byte)
{
	if((row==0)|(row>8))//只有八列，对于超出的数据要做溢出判断
	{
		return;
	}
	P2=(P2&0x1F)|0x00;//先让控制列选的D触发器关闭数据传输
	P0=(0x01)<<(row-1);//准备列选信号
	US_delay(1);//等待电平稳定后
	P2=(P2&0x1F)|0xC0;//选择控制列选的D触发器
	US_delay(5);//等待D触发器动作
	P2=(P2&0x1F)|0x00;//控制列选的D触发器锁存
	P0=~Byte;//准备显示数据信号
	US_delay(1);//等待电平稳定后
	P2=(P2&0x1F)|0xE0;//选择控制数据的D触发器
	MS_delay(1);//延时给人视觉停留
	P0=0xFF;//清除这一次的显示数据，消隐
	P2=(P2&0x1F)|0x00;//锁存数据
}

void display_picture(len)
{
	unsigned char i=0;//扫屏循环变量
	unsigned char offset=0;//偏移量
	while(1)
	{
		now=currenttim;//等待变量
		while(1)
		{
			for(i=0;i<8;i++)
			{
				Display_line(i+1,Display[(i+offset)%len]);
			}
			if(currenttim-now>100)//每一帧图像静止显示0.1S
			{
				break;
			}
		}
		offset++;//显示下一帧
		if(offset+1>len)//基准点显示图像完成，清0进行下一轮显示
		{
			offset=0;
		}
		LED_Display(offset);
	}
}

void static_display(void)
{
	unsigned char i=0;
	for(i=0;i<8;i++)
	{
		Display_line(i+1,picture[i]);
	}
}

void LED_Display(unsigned char Byte)
{
	P2=(P2&0x1F)|0x00;
	P0=~Byte;
	P2=(P2&0x1F)|0x80;
	US_delay(1);
	P2=(P2&0x1F)|0x00;
}

