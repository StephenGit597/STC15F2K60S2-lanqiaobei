void Single_Seg_Display(unsigned char sel,unsigned char Byte,unsigned char dot)
{
	if((sel==0)|(sel>8)|(Byte>15)|(dot>1))//输入非法，直接返回
	{
		return;
	}
	P2=(P2&0x1F)|0x00;//首先选择空（失能），注意P27,P26,P25只能同时赋值，不能分开赋值，否则会导致其它功能误触发
	P0=0x00;//先把P0置0，初始化
	US_Delay(1);//延时，保证电平稳定
	
	P0=0x01<<(sel-1);//独热码,先确定好位选数据
	US_Delay(1);//等待数据稳定
	P2=(P2&0x1F)|0xC0;//11000000,P27=1,P26=1,P25=0，再进行位选，D触发器读取P0准备好的数据
	US_Delay(3);//延时，等待D触发器充分读取数据
	P2=(P2&0x1F)|0x00;//选择空，位选触发器锁存数据
	US_Delay(1);//等待稳定
	
	P0=Segcode[Byte];//段码，先确定好段码，共阳段码1，熄灭，0点亮
	if(dot)//需要显示该位的小数点
	{
		P07=0;//打开该位的小数点开关
	}
	US_Delay(1);//等待稳定
	P2=(P2&0x1F)|0xE0;//11100000,P27=1,P26=1,P25=1,再把数据接到段码区,显示数据
	MS_Delay(1);//延时1毫秒,给定充分点亮时间
	P0=0xFF;//全部熄灭，数码管所有等关闭，防止下一次位选的时候，D触发器保留的数据给下一位造成串扰
	P2=(P2&0x1F)|0x00;//选择空，位选触发器锁存数据（注此时的数据是不让数码管任何部分点亮）
	
	P0=0x00;//准备清除该位的位选，避免对下一位产生干扰
	US_Delay(1);//等待稳定
	P2=(P2&0x1F)|0xC0;//选择位选数据输入，把00000000（0x00）置如到D触发器
	US_Delay(1);//等待稳定
	P2=(P2&0x1F)|0x00;//选择空，位选触发器锁存数据（此时触发器锁存0x00）
}